function [MOVINGREG] = registerImages(MOVING,FIXED)
%registerImages  Register grayscale images using auto-generated code from Registration Estimator app.
%  [MOVINGREG] = registerImages(MOVING,FIXED) Register grayscale images
%  MOVING and FIXED using auto-generated code from the Registration
%  Estimator app. The values for all registration parameters were set
%  interactively in the app and result in the registered image stored in the
%  structure array MOVINGREG.

% Auto-generated by registrationEstimator app on 24-Jun-2019
%-----------------------------------------------------------


% Default spatial referencing objects
fixedRefObj = imref2d(size(FIXED));
movingRefObj = imref2d(size(MOVING));

% Intensity-based registration
[optimizer, metric] = imregconfig('monomodal');
optimizer.GradientMagnitudeTolerance = 1.00000e-04;
optimizer.MinimumStepLength = 1.00000e-05;
optimizer.MaximumStepLength = 6.25000e-02;
optimizer.MaximumIterations = 100;
optimizer.RelaxationFactor = 0.500000;

% Align centers
[xFixed,yFixed] = meshgrid(1:size(FIXED,2),1:size(FIXED,1));
[xMoving,yMoving] = meshgrid(1:size(MOVING,2),1:size(MOVING,1));
sumFixedIntensity = sum(FIXED(:));
sumMovingIntensity = sum(MOVING(:));
fixedXCOM = (fixedRefObj.PixelExtentInWorldX .* (sum(xFixed(:).*double(FIXED(:))) ./ sumFixedIntensity)) + fixedRefObj.XWorldLimits(1);
fixedYCOM = (fixedRefObj.PixelExtentInWorldY .* (sum(yFixed(:).*double(FIXED(:))) ./ sumFixedIntensity)) + fixedRefObj.YWorldLimits(1);
movingXCOM = (movingRefObj.PixelExtentInWorldX .* (sum(xMoving(:).*double(MOVING(:))) ./ sumMovingIntensity)) + movingRefObj.XWorldLimits(1);
movingYCOM = (movingRefObj.PixelExtentInWorldY .* (sum(yMoving(:).*double(MOVING(:))) ./ sumMovingIntensity)) + movingRefObj.YWorldLimits(1);
translationX = fixedXCOM - movingXCOM;
translationY = fixedYCOM - movingYCOM;

if ~isfinite(translationX)
    translationX = 0;
end
if ~isfinite(translationY)
    translationY = 0;
end

% Coarse alignment
initTform = affine2d();
initTform.T(3,1:2) = [translationX, translationY];

% Apply Gaussian blur
fixedInit = imgaussfilt(FIXED,1.909722);
movingInit = imgaussfilt(MOVING,1.909722);

% Binarize images
fixedInit = imbinarize(mat2gray(fixedInit), 'adaptive', 'ForegroundPolarity', 'bright', 'Sensitivity', 0.5);
movingInit = imbinarize(mat2gray(movingInit), 'adaptive', 'ForegroundPolarity', 'bright', 'Sensitivity', 0.5);

% Normalize images
movingInit = mat2gray(movingInit);
fixedInit = mat2gray(fixedInit);

% Apply transformation
tform = imregtform(movingInit,movingRefObj,fixedInit,fixedRefObj,'translation',optimizer,metric,'PyramidLevels',5,'InitialTransformation',initTform);
MOVINGREG.Transformation = tform;
% circshift instead of imwarp
MOVINGREG.RegisteredImage = circshift(MOVING, [floor(tform.T(3,2)) floor(tform.T(3,1))]);

% Store spatial referencing object
MOVINGREG.SpatialRefObj = fixedRefObj;

end

